{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "bluetooth-device-card",
  "type": "registry:component",
  "title": "Bluetooth Device Card",
  "description": "Display a card of bluetooth device information.",
  "registryDependencies": [
    "button",
    "progress",
    "tooltip"
  ],
  "files": [
    {
      "path": "registry/new-york/blocks/bluetooth/bluetooth-device-card.tsx",
      "content": "\"use client\";\n\nimport { useState, useEffect } from \"react\";\nimport { Button } from \"@/registry/new-york/ui/button\";\nimport { BluetoothManager, BluetoothDevice, DeviceInformation } from \"@/registry/new-york/blocks/bluetooth/bluetooth-utils\";\nimport { Battery, ChevronDown, ChevronUp, Info, RefreshCw, Trash2, Wifi, WifiOff } from \"lucide-react\";\nimport { Progress } from \"@/registry/new-york/ui/progress\";\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipProvider,\n  TooltipTrigger,\n} from \"@/registry/new-york/ui/tooltip\";\n// import { Accordion, AccordionItem, AccordionTrigger, AccordionContent } from \"@radix-ui/react-accordion\";\nimport { BluetoothStatus } from \"@/registry/new-york/blocks/bluetooth/bluetooth-status\";\nimport { Accordion, AccordionItem, AccordionTrigger, AccordionContent } from \"@/registry/new-york/ui/accordion\";\n\ninterface BluetoothDeviceCardProps {\n  device: BluetoothDevice;\n  onDeviceSelected?: (device: BluetoothDevice) => void;\n  onDeviceRemoved?: (device: BluetoothDevice) => void;\n  onError?: (error: Error) => void;\n}\n\nexport function BluetoothDeviceCard({\n  device,\n  onDeviceSelected,\n  onDeviceRemoved,\n  onError\n}: BluetoothDeviceCardProps) {\n  const [isExpanded, setIsExpanded] = useState(false);\n  const [deviceInfo, setDeviceInfo] = useState<DeviceInformation | null>(null);\n  const [batteryLevel, setBatteryLevel] = useState<number | null>(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [loadingState, setLoadingState] = useState<{\n    deviceInfo: boolean;\n    battery: boolean;\n    characteristics: boolean;\n  }>({\n    deviceInfo: false,\n    battery: false,\n    characteristics: false\n  });\n  const bluetoothManager = BluetoothManager.getInstance();\n  const [subscribedCharacteristics, setSubscribedCharacteristics] = useState<Set<string>>(new Set());\n  const [lastUpdateTime, setLastUpdateTime] = useState<Date | null>(null);\n  const [errorState, setErrorState] = useState<{\n    deviceInfo: string | null;\n    battery: string | null;\n    characteristics: string | null;\n  }>({\n    deviceInfo: null,\n    battery: null,\n    characteristics: null\n  });\n\n  const isGattError = (error: any): boolean => {\n    return error instanceof Error &&\n      (error.message.includes('GATT operation already in progress') ||\n        error.message.includes('GATT Server is disconnected'));\n  };\n\n  const retryOperation = async <T,>(\n    operation: () => Promise<T>,\n    maxRetries: number = 3,\n    delay: number = 1000\n  ): Promise<T> => {\n    let lastError: Error | null = null;\n    for (let i = 0; i < maxRetries; i++) {\n      try {\n        return await operation();\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error('Unknown error');\n        if (!isGattError(error) || i === maxRetries - 1) {\n          throw lastError;\n        }\n        await new Promise(resolve => setTimeout(resolve, delay * (i + 1)));\n      }\n    }\n    throw lastError;\n  };\n\n  // Load device information when device is connected\n  useEffect(() => {\n    const loadDeviceInfo = async () => {\n      if (device.isConnected && (!deviceInfo || !lastUpdateTime || Date.now() - lastUpdateTime.getTime() > 30000)) {\n        setIsLoading(true);\n        setLoadingState({\n          deviceInfo: true,\n          battery: true,\n          characteristics: true\n        });\n\n        try {\n          // Read all characteristics first\n          await retryOperation(async () => {\n            setLoadingState(prev => ({ ...prev, characteristics: true }));\n            await bluetoothManager.readAllCharacteristics(device);\n            setLoadingState(prev => ({ ...prev, characteristics: false }));\n          });\n\n          // Then get the specific information we want to display\n          const [info, battery] = await Promise.all([\n            retryOperation(async () => {\n              setLoadingState(prev => ({ ...prev, deviceInfo: true }));\n              const result = await bluetoothManager.readDeviceInformation(device);\n              setLoadingState(prev => ({ ...prev, deviceInfo: false }));\n              return result;\n            }),\n            retryOperation(async () => {\n              setLoadingState(prev => ({ ...prev, battery: true }));\n              const result = await bluetoothManager.readBatteryLevel(device);\n              setLoadingState(prev => ({ ...prev, battery: false }));\n              return result;\n            })\n          ]);\n\n          setDeviceInfo(info);\n          setBatteryLevel(battery);\n          setLastUpdateTime(new Date());\n          setErrorState({\n            deviceInfo: null,\n            battery: null,\n            characteristics: null\n          });\n        } catch (error) {\n          console.error('Failed to load device information:', error);\n          if (isGattError(error)) {\n            setErrorState({\n              deviceInfo: 'GATT operation failed. Please try again.',\n              battery: 'GATT operation failed. Please try again.',\n              characteristics: 'GATT operation failed. Please try again.'\n            });\n          } else {\n            onError?.(error instanceof Error ? error : new Error('Failed to load device information'));\n          }\n        } finally {\n          setIsLoading(false);\n        }\n      }\n    };\n\n    loadDeviceInfo();\n  }, [device.isConnected, device.id]);\n\n  const refreshDeviceInfo = async () => {\n    if (!device.gatt) return;\n\n    setIsLoading(true);\n    setLoadingState({\n      deviceInfo: true,\n      battery: true,\n      characteristics: true\n    });\n\n    try {\n      // Read all characteristics first\n      await retryOperation(async () => {\n        setLoadingState(prev => ({ ...prev, characteristics: true }));\n        await bluetoothManager.readAllCharacteristics(device);\n        setLoadingState(prev => ({ ...prev, characteristics: false }));\n      });\n\n      // Then get the specific information we want to display\n      const [info, battery] = await Promise.all([\n        retryOperation(async () => {\n          setLoadingState(prev => ({ ...prev, deviceInfo: true }));\n          const result = await bluetoothManager.readDeviceInformation(device);\n          setLoadingState(prev => ({ ...prev, deviceInfo: false }));\n          return result;\n        }),\n        retryOperation(async () => {\n          setLoadingState(prev => ({ ...prev, battery: true }));\n          const result = await bluetoothManager.readBatteryLevel(device);\n          setLoadingState(prev => ({ ...prev, battery: false }));\n          return result;\n        })\n      ]);\n\n      setDeviceInfo(info);\n      setBatteryLevel(battery);\n      setLastUpdateTime(new Date());\n      setErrorState({\n        deviceInfo: null,\n        battery: null,\n        characteristics: null\n      });\n    } catch (error) {\n      console.error('Failed to refresh device information:', error);\n      if (isGattError(error)) {\n        setErrorState({\n          deviceInfo: 'GATT operation failed. Please try again.',\n          battery: 'GATT operation failed. Please try again.',\n          characteristics: 'GATT operation failed. Please try again.'\n        });\n      } else {\n        onError?.(error instanceof Error ? error : new Error('Failed to refresh device information'));\n      }\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleConnect = async () => {\n    try {\n      await bluetoothManager.connectToDevice(device.id);\n      onDeviceSelected?.(device);\n      // Device info will be loaded automatically by the useEffect\n    } catch (error) {\n      onError?.(error instanceof Error ? error : new Error('Failed to connect to device'));\n    }\n  };\n\n  const handleDisconnect = async () => {\n    try {\n      await bluetoothManager.disconnectDevice(device.id);\n      // Only refresh the specific device that was disconnected\n      await bluetoothManager.refreshDevices(device.id);\n    } catch (error) {\n      onError?.(error instanceof Error ? error : new Error('Failed to disconnect device'));\n    }\n  };\n\n  const handleRemove = async () => {\n    try {\n      await bluetoothManager.removeDevice(device.id);\n      onDeviceRemoved?.(device);\n    } catch (error) {\n      onError?.(error instanceof Error ? error : new Error('Failed to remove device'));\n    }\n  };\n\n  const isSubscribed = (serviceUuid: string, characteristicUuid: string) => {\n    return subscribedCharacteristics.has(`${serviceUuid}-${characteristicUuid}`);\n  };\n\n  const handleReadCharacteristic = async (serviceUuid: string, characteristicUuid: string) => {\n    if (!device.gatt) return;\n    try {\n      const value = await bluetoothManager.readCharacteristic(device, serviceUuid, characteristicUuid);\n      console.log(`Read value from ${characteristicUuid}:`, value);\n      // Update the UI with the new value\n      refreshDeviceInfo();\n    } catch (error) {\n      console.error('Failed to read characteristic:', error);\n      onError?.(error instanceof Error ? error : new Error('Failed to read characteristic'));\n    }\n  };\n\n  const handleWriteCharacteristic = async (serviceUuid: string, characteristicUuid: string) => {\n    if (!device.gatt) return;\n    try {\n      // TODO: Implement write dialog\n      console.log('Write to characteristic:', characteristicUuid);\n    } catch (error) {\n      console.error('Failed to write characteristic:', error);\n      onError?.(error instanceof Error ? error : new Error('Failed to write characteristic'));\n    }\n  };\n\n  const handleToggleNotifications = async (serviceUuid: string, characteristicUuid: string) => {\n    if (!device.gatt) return;\n    try {\n      const key = `${serviceUuid}-${characteristicUuid}`;\n      if (isSubscribed(serviceUuid, characteristicUuid)) {\n        await bluetoothManager.stopNotifications(device, serviceUuid, characteristicUuid);\n        setSubscribedCharacteristics(prev => {\n          const newSet = new Set(prev);\n          newSet.delete(key);\n          return newSet;\n        });\n      } else {\n        await bluetoothManager.startNotifications(device, serviceUuid, characteristicUuid);\n        setSubscribedCharacteristics(prev => {\n          const newSet = new Set(prev);\n          newSet.add(key);\n          return newSet;\n        });\n      }\n    } catch (error) {\n      console.error('Failed to toggle notifications:', error);\n      onError?.(error instanceof Error ? error : new Error('Failed to toggle notifications'));\n    }\n  };\n\n  const getPropertyDescription = (prop: string): string => {\n    switch (prop.toLowerCase()) {\n      case 'read':\n        return 'This characteristic can be read';\n      case 'write':\n        return 'This characteristic can be written to';\n      case 'notify':\n        return 'This characteristic can send notifications';\n      case 'indicate':\n        return 'This characteristic can send indications';\n      case 'broadcast':\n        return 'This characteristic can broadcast';\n      case 'writewithoutresponse':\n        return 'This characteristic can be written to without response';\n      case 'authenticatedsignedwrites':\n        return 'This characteristic supports authenticated signed writes';\n      case 'extendedproperties':\n        return 'This characteristic has extended properties';\n      default:\n        return prop;\n    }\n  };\n\n  const formatCharacteristicValue = (value: DataView): string => {\n    try {\n      // Try to decode as UTF-8 text first\n      const text = new TextDecoder().decode(value);\n      if (text && !text.includes('\\u0000')) {\n        return text;\n      }\n    } catch (e) {\n      // If text decoding fails, try other formats\n    }\n\n    // If it's a single byte value (like battery level)\n    if (value.byteLength === 1) {\n      return value.getUint8(0).toString();\n    }\n\n    // If it's a 16-bit value\n    if (value.byteLength === 2) {\n      return value.getUint16(0, true).toString();\n    }\n\n    // If it's a 32-bit value\n    if (value.byteLength === 4) {\n      return value.getUint32(0, true).toString();\n    }\n\n    // If all else fails, show as hex\n    const bytes = new Uint8Array(value.buffer);\n    return Array.from(bytes)\n      .map(b => b.toString(16).padStart(2, '0'))\n      .join(' ');\n  };\n\n  return (\n    <div className=\"flex flex-col space-y-2 p-4 border-b last:border-b-0\">\n      <div className=\"flex items-center justify-between space-y-2\">\n        <div className=\"flex flex-col items-start gap-1\">\n          <span className=\"font-medium\">\n            {device.name || 'Unknown Device'}\n          </span>\n          <span className=\"text-xs text-muted-foreground font-mono\">\n            {device.id}\n          </span>\n        </div>\n        <div className=\"flex items-center gap-2\">\n          \n\n          <BluetoothStatus  device={device}/>\n\n          {!device.isConnected && (\n            <Button\n              variant=\"ghost\"\n              size=\"sm\"\n              onClick={async () => {\n                try {\n                  await handleConnect();\n                  setIsExpanded(true);\n                } catch (error) {\n                  console.error('Failed to connect to device:', error);\n                }\n              }}\n              className=\"text-green-500 hover:text-green-700\"\n            >\n              <Wifi className=\"h-4 w-4\" />\n              <span>Connect</span>\n            </Button>\n          )}\n\n\n          <TooltipProvider>\n            <Tooltip>\n              <TooltipTrigger asChild>\n                {device.isConnected ? (\n                  <Button\n                    variant=\"ghost\"\n                    size=\"sm\"\n                    onClick={handleDisconnect}\n                    className=\"text-red-500 hover:text-red-700\"\n                  >\n                    <WifiOff className=\"h-4 w-4\" />\n                    <span>Disconnect</span>\n                  </Button>\n                ) : (\n                  <Button\n                    variant=\"ghost\"\n                    size=\"sm\"\n                    onClick={handleRemove}\n                    className=\"text-red-500 hover:text-red-700\"\n                  >\n                    <Trash2 className=\"h-4 w-4\" />\n                    {/* <span>Remove</span> */}\n                  </Button>\n                )}\n              </TooltipTrigger>\n              <TooltipContent>\n                <p>{device.isConnected ? 'Disconnect from device' : 'Remove device'}</p>\n              </TooltipContent>\n            </Tooltip>\n          </TooltipProvider>\n\n          {device.isConnected && (\n            <Button\n              variant=\"ghost\"\n              size=\"sm\"\n              onClick={() => setIsExpanded(!isExpanded)}\n            >\n              {isExpanded ? (\n                <ChevronUp className=\"h-4 w-4\" />\n              ) : (\n                <ChevronDown className=\"h-4 w-4\" />\n              )}\n            </Button>\n          )}\n        </div>\n      </div>\n\n      {device.isConnected && isExpanded && (\n        <div className=\"space-y-4 pl-4 border-l\">\n          {batteryLevel !== null && (\n            <div className=\"space-y-2\">\n              <div className=\"flex items-center gap-2 text-sm\">\n                <Battery className=\"h-4 w-4\" />\n                <span>Battery Level</span>\n                {loadingState.battery ? (\n                  <div className=\"ml-auto flex items-center gap-2\">\n                    <RefreshCw className=\"h-4 w-4 animate-spin\" />\n                    <span className=\"text-muted-foreground\">Loading...</span>\n                  </div>\n                ) : (\n                  <span className=\"ml-auto font-medium\">{batteryLevel}%</span>\n                )}\n              </div>\n              {errorState.battery && (\n                <div className=\"text-xs text-red-500\">{errorState.battery}</div>\n              )}\n              <Progress value={batteryLevel} className=\"h-2\" />\n            </div>\n          )}\n\n          {deviceInfo && (\n            <div className=\"space-y-2\">\n              <div className=\"flex items-center gap-2 text-sm text-muted-foreground\">\n                <Info className=\"h-4 w-4\" />\n                <span>Device Details</span>\n                {loadingState.deviceInfo ? (\n                  <div className=\"ml-auto flex items-center gap-2\">\n                    <RefreshCw className=\"h-4 w-4 animate-spin\" />\n                    <span className=\"text-muted-foreground\">Loading...</span>\n                  </div>\n                ) : (\n                  <Button\n                    variant=\"ghost\"\n                    size=\"sm\"\n                    onClick={refreshDeviceInfo}\n                    disabled={isLoading}\n                    className=\"ml-auto\"\n                  >\n                    <RefreshCw className={`h-4 w-4 ${isLoading ? 'animate-spin' : ''}`} />\n                  </Button>\n                )}\n              </div>\n              {errorState.deviceInfo && (\n                <div className=\"text-xs text-red-500\">{errorState.deviceInfo}</div>\n              )}\n              {lastUpdateTime && (\n                <div className=\"text-xs text-muted-foreground\">\n                  Last updated: {lastUpdateTime.toLocaleTimeString()}\n                </div>\n              )}\n              <div className=\"grid gap-2 text-sm\">\n                {deviceInfo.manufacturerName && (\n                  <div className=\"flex justify-between\">\n                    <span className=\"text-muted-foreground\">Manufacturer</span>\n                    <span>{deviceInfo.manufacturerName}</span>\n                  </div>\n                )}\n                {deviceInfo.modelNumber && (\n                  <div className=\"flex justify-between\">\n                    <span className=\"text-muted-foreground\">Model</span>\n                    <span>{deviceInfo.modelNumber}</span>\n                  </div>\n                )}\n                {deviceInfo.serialNumber && (\n                  <div className=\"flex justify-between\">\n                    <span className=\"text-muted-foreground\">Serial Number</span>\n                    <span>{deviceInfo.serialNumber}</span>\n                  </div>\n                )}\n                {deviceInfo.hardwareRevision && (\n                  <div className=\"flex justify-between\">\n                    <span className=\"text-muted-foreground\">Hardware Revision</span>\n                    <span>{deviceInfo.hardwareRevision}</span>\n                  </div>\n                )}\n                {deviceInfo.firmwareRevision && (\n                  <div className=\"flex justify-between\">\n                    <span className=\"text-muted-foreground\">Firmware Revision</span>\n                    <span>{deviceInfo.firmwareRevision}</span>\n                  </div>\n                )}\n                {deviceInfo.softwareRevision && (\n                  <div className=\"flex justify-between\">\n                    <span className=\"text-muted-foreground\">Software Revision</span>\n                    <span>{deviceInfo.softwareRevision}</span>\n                  </div>\n                )}\n              </div>\n            </div>\n          )}\n\n          {device.services && device.services.length > 0 && (\n            <div className=\"space-y-2\">\n              <div className=\"flex items-center gap-2 text-sm text-muted-foreground\">\n                <Info className=\"h-4 w-4\" />\n                <span>Services & Characteristics</span>\n                <Button\n                  variant=\"ghost\"\n                  size=\"sm\"\n                  onClick={refreshDeviceInfo}\n                  disabled={isLoading}\n                  className=\"ml-auto\"\n                >\n                  <RefreshCw className={`h-4 w-4 ${isLoading ? 'animate-spin' : ''}`} />\n                </Button>\n              </div>\n              <Accordion type=\"multiple\" className=\"w-full\">\n                {device.services.map((service) => (\n                  <AccordionItem key={service.uuid} value={service.uuid}>\n                    <AccordionTrigger className=\"text-sm py-2\">\n                    <span className=\"cursor-help\">\n                              {bluetoothManager.getServiceName(service.uuid) || service.uuid}\n                            </span>\n                    </AccordionTrigger>\n                    <AccordionContent>\n                      <div className=\"space-y-2 pl-4\">\n                        {service.characteristics.map((char) => (\n                          <div key={char.uuid} className=\"text-sm text-muted-foreground\">\n                            <div className=\"flex items-center justify-between\">\n                              <span className=\"cursor-help\">\n                                {bluetoothManager.getCharacteristicName(char.uuid) || char.uuid}\n\n                              </span>\n                              <div className=\"flex items-center gap-2\">\n\n                                <div>\n                                  {bluetoothManager.getCharacteristicValue(char.uuid) ? (\n                                    <div className=\"text-xs text-muted-foreground\">\n                                      {formatCharacteristicValue(bluetoothManager.getCharacteristicValue(char.uuid)!)}\n                                    </div>\n                                  ) : null}\n                                </div>\n                                <div className=\"flex gap-1\">\n                                  {char.properties.map((prop) => (\n                                    <TooltipProvider key={prop}>\n                                      <Tooltip>\n                                        <TooltipTrigger asChild>\n                                          <span\n                                            className=\"px-1 py-0.5 text-xs rounded bg-muted cursor-help\"\n                                          >\n                                            {prop}\n                                          </span>\n                                        </TooltipTrigger>\n                                        <TooltipContent>\n                                          <p>{getPropertyDescription(prop)}</p>\n                                        </TooltipContent>\n                                      </Tooltip>\n                                    </TooltipProvider>\n                                  ))}\n                                </div>\n                                <div className=\"flex gap-1\">\n                                  {char.properties.includes('read') && (\n                                    <Button\n                                      variant=\"ghost\"\n                                      size=\"sm\"\n                                      className=\"h-6 px-2\"\n                                      onClick={() => handleReadCharacteristic(service.uuid, char.uuid)}\n                                    >\n                                      <RefreshCw className=\"h-4 w-4\" />test\n                                    </Button>\n                                  )}\n                                  {char.properties.includes('write') && (\n                                    <Button\n                                      variant=\"ghost\"\n                                      size=\"sm\"\n                                      className=\"h-6 px-2\"\n                                      onClick={() => handleWriteCharacteristic(service.uuid, char.uuid)}\n                                    >\n                                      Write\n                                    </Button>\n                                  )}\n                                  {char.properties.includes('notify') && (\n                                    <Button\n                                      variant=\"ghost\"\n                                      size=\"sm\"\n                                      className=\"h-6 px-2\"\n                                      onClick={() => handleToggleNotifications(service.uuid, char.uuid)}\n                                    >\n                                      {isSubscribed(service.uuid, char.uuid) ? 'Unsubscribe' : 'Subscribe'}\n                                    </Button>\n                                  )}\n                                </div>\n                              </div>\n                            </div>\n                            {char.value && (\n                              <div className=\"text-xs mt-1 flex items-center gap-2\">\n                                <span>Value:</span>\n                                <code className=\"bg-muted px-2 py-1 rounded\">\n                                  {formatCharacteristicValue(char.value)}\n                                </code>\n                                {char.lastUpdated && (\n                                  <span className=\"text-xs text-muted-foreground\">\n                                    (Updated: {new Date(char.lastUpdated).toLocaleTimeString()})\n                                  </span>\n                                )}\n                              </div>\n                            )}\n                          </div>\n                        ))}\n                      </div>\n                    </AccordionContent>\n                  </AccordionItem>\n                ))}\n              </Accordion>\n            </div>\n          )}\n        </div>\n      )}\n    </div>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/bluetooth/bluetooth-utils.ts",
      "content": "import { GattLookup } from '@/registry/new-york/blocks/bluetooth/gatt-services';\n\nexport interface BluetoothDevice {\n  id: string;\n  name: string | null;\n  gatt?: BluetoothRemoteGATTServer;\n  isConnected: boolean;\n  lastSeen: Date;\n  services?: Service[];\n  deviceInfo?: DeviceInformation;\n}\n\nexport interface Service {\n  uuid: string;\n  name: string;\n  characteristics: Characteristic[];\n}\n\nexport interface Characteristic {\n  uuid: string;\n  name: string;\n  properties: string[];\n  value?: DataView;\n  lastUpdated?: Date;\n}\n\nexport interface DeviceInformation {\n  manufacturerName?: string;\n  modelNumber?: string;\n  serialNumber?: string;\n  hardwareRevision?: string;\n  firmwareRevision?: string;\n  softwareRevision?: string;\n  systemId?: string;\n  ieee11073?: string;\n  pnpId?: string;\n}\n\nexport interface CustomCharacteristic {\n  uuid: string;\n  key: string;\n  name: string;\n  valueFormatter?: (value: DataView) => string;\n  onChange?: (value: string) => void;\n}\n\ninterface Device {\n  id: string;\n  name: string;\n  isConnected: boolean;\n  isPaired: boolean;\n  lastSeen: Date;\n  services: Service[];\n  characteristics: Characteristic[];\n}\n\ntype EventType = \n  | 'devicesChanged'\n  | 'deviceConnected'\n  | 'deviceDisconnected'\n  | 'error'\n  | 'scanError'\n  | 'connectionError'\n  | 'disconnectionError'\n  | 'serviceDiscovery'\n  | 'characteristicRead'\n  | 'characteristicWrite'\n  | 'devicePaired'\n  | 'connectError'\n  | 'disconnectError'\n  | 'removeError'\n  | 'serviceDiscovered'\n  | 'serviceError'\n  | 'characteristicError';\n\ntype EventCallback = (data: any) => void;\n\nexport class BluetoothManager {\n  private static instance: BluetoothManager;\n  private devices: BluetoothDevice[] = [];\n  private eventListeners: Map<EventType, Set<EventCallback>> = new Map();\n  private characteristicValues: Map<string, DataView> = new Map();\n  private characteristicNotifications: Map<string, (event: Event) => void> = new Map();\n  private customCharacteristics: CustomCharacteristic[] = [];\n  private characteristicSubscriptions: Map<string, Set<(value: string) => void>> = new Map();\n  private gattLookup: GattLookup;\n\n  private constructor() {\n    this.gattLookup = GattLookup.getInstance();\n    this.loadDevices();\n    this.setupBluetoothEvents();\n  }\n\n  public static getInstance(): BluetoothManager {\n    if (!BluetoothManager.instance) {\n      BluetoothManager.instance = new BluetoothManager();\n    }\n    return BluetoothManager.instance;\n  }\n\n  private loadDevices() {\n    try {\n      const storedDevices = localStorage.getItem('bluetoothDevices');\n      if (storedDevices) {\n        this.devices = JSON.parse(storedDevices).map((device: any) => ({\n          ...device,\n          lastSeen: new Date(device.lastSeen)\n        }));\n      }\n    } catch (error) {\n      this.emit('error', new Error('Failed to load devices from storage'));\n    }\n  }\n\n  private saveDevices() {\n    try {\n      localStorage.setItem('bluetoothDevices', JSON.stringify(this.devices));\n    } catch (error) {\n      this.emit('error', new Error('Failed to save devices to storage'));\n    }\n  }\n\n  private setupBluetoothEvents() {\n    if (navigator.bluetooth) {\n      try {\n        navigator.bluetooth.addEventListener('advertisementreceived', (event) => {\n          this.handleDeviceUpdate(event.device as unknown as BluetoothDevice);\n        });\n      } catch (error) {\n        this.emit('error', new Error('Failed to setup Bluetooth event listeners'));\n      }\n    }\n  }\n\n  private handleDeviceUpdate(device: BluetoothDevice) {\n    try {\n      const existingDevice = this.devices.find(d => d.id === device.id);\n      if (existingDevice) {\n        existingDevice.lastSeen = new Date();\n        existingDevice.isConnected = device.isConnected;\n      } else {\n        this.devices.push({\n          ...device,\n          lastSeen: new Date(),\n          isConnected: false\n        });\n      }\n      this.saveDevices();\n      this.emit('devicesChanged', this.devices);\n    } catch (error) {\n      this.emit('error', new Error('Failed to update device information'));\n    }\n  }\n\n  public addListener(event: EventType, callback: EventCallback) {\n    if (!this.eventListeners.has(event)) {\n      this.eventListeners.set(event, new Set());\n    }\n    this.eventListeners.get(event)?.add(callback);\n  }\n\n  public removeListener(event: EventType, callback: EventCallback) {\n    this.eventListeners.get(event)?.delete(callback);\n  }\n\n  private emit(event: EventType, data: any) {\n    this.eventListeners.get(event)?.forEach(callback => callback(data));\n  }\n\n  public isBluetoothAvailable(): boolean {\n    return !!navigator.bluetooth;\n  }\n\n  public getDevices(): BluetoothDevice[] {\n    return [...this.devices];\n  }\n\n  public async scanForDevices(): Promise<BluetoothDevice> {\n    if (!this.isBluetoothAvailable()) {\n      const error = new Error('Bluetooth is not available');\n      this.emit('scanError', error);\n      throw error;\n    }\n\n    try {\n      const device = await navigator.bluetooth.requestDevice({\n        acceptAllDevices: true,\n        optionalServices: ['battery_service', 'device_information']\n      });\n\n      const newDevice: BluetoothDevice = {\n        id: device.id,\n        name: device.name || null,\n        gatt: device.gatt,\n        isConnected: false,\n        lastSeen: new Date()\n      };\n\n      // Add the device to our list\n      this.handleDeviceUpdate(newDevice);\n\n      // Try to connect to the device\n      try {\n        console.log(\"Attempting to connect to newly paired device:\", newDevice.name || newDevice.id);\n        const connectedDevice = await this.connectToDevice(newDevice.id);\n        console.log(\"Successfully connected to device:\", connectedDevice.name || connectedDevice.id);\n        return connectedDevice;\n      } catch (error) {\n        console.error(\"Failed to connect to device after pairing:\", error);\n        // Still return the device even if connection fails\n        return newDevice;\n      }\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Failed to scan for devices');\n      this.emit('scanError', err);\n      throw err;\n    }\n  }\n\n  private async readDeviceInformationWithRetry(\n    device: BluetoothDevice,\n    maxRetries: number = 3,\n    retryDelay: number = 1000\n  ): Promise<DeviceInformation> {\n    let lastError: Error | null = null;\n    \n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      try {\n        console.log(`Attempting to read device information (attempt ${attempt}/${maxRetries})...`);\n        const info = await this.readDeviceInformation(device);\n        console.log(`Successfully read device information on attempt ${attempt}`);\n        return info;\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error('Unknown error');\n        console.error(`Failed to read device information (attempt ${attempt}/${maxRetries}):`, {\n          error: lastError.message,\n          stack: lastError.stack,\n          deviceId: device.id,\n          deviceName: device.name\n        });\n        \n        if (attempt < maxRetries) {\n          console.log(`Waiting ${retryDelay}ms before retry...`);\n          await new Promise(resolve => setTimeout(resolve, retryDelay));\n        }\n      }\n    }\n    \n    throw lastError || new Error('Failed to read device information after all retries');\n  }\n\n  public async refreshDeviceInformation(device: BluetoothDevice): Promise<DeviceInformation> {\n    if (!device.gatt) {\n      throw new Error('Device not connected');\n    }\n\n    try {\n      console.log(`Refreshing device information for ${device.name || device.id}...`);\n      const deviceInfo = await this.readDeviceInformationWithRetry(device);\n      device.deviceInfo = deviceInfo;\n      this.handleDeviceUpdate(device);\n      this.emit('deviceConnected', device);\n      console.log('Device information refreshed successfully:', deviceInfo);\n      return deviceInfo;\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Failed to refresh device information');\n      console.error('Error refreshing device information:', {\n        error: err.message,\n        stack: err.stack,\n        deviceId: device.id,\n        deviceName: device.name\n      });\n      this.emit('error', err);\n      throw err;\n    }\n  }\n\n  public async connectToDevice(deviceId: string): Promise<BluetoothDevice> {\n    console.log(\"Connecting to device:\", deviceId);\n    const device = this.devices.find(d => d.id === deviceId);\n    console.log(\"device\", device);\n    if (!device) {\n      const error = new Error('Device not found');\n      this.emit('connectError', error);\n      throw error;\n    }\n\n    try {\n      const bluetoothDevice = await navigator.bluetooth.requestDevice({\n        acceptAllDevices: true,\n        optionalServices: ['battery_service', 'device_information']\n      });\n\n      if (bluetoothDevice.id !== deviceId) {\n        throw new Error('Device ID mismatch');\n      }\n\n      const server = await bluetoothDevice.gatt?.connect();\n      if (server) {\n        device.gatt = server;\n        device.isConnected = true;\n        \n        // Query primary services\n        console.log(\"Querying primary services...\");\n        const services = await server.getPrimaryServices();\n        console.log(\"Found services:\", services.length);\n        \n        // Log each service's details\n        for (const service of services) {\n          console.log(`Service: ${this.getServiceName(service.uuid)} (${service.uuid})`);\n          try {\n            const characteristics = await service.getCharacteristics();\n            console.log(`  Characteristics (${characteristics.length}):`);\n            for (const char of characteristics) {\n              console.log(`    - ${this.getCharacteristicName(char.uuid)} (${char.uuid})`);\n              console.log(`      Properties: ${Object.keys(char.properties).join(', ')}`);\n            }\n          } catch (error) {\n            console.error(`Failed to get characteristics for service ${service.uuid}:`, {\n              error: error instanceof Error ? error.message : 'Unknown error',\n              stack: error instanceof Error ? error.stack : undefined,\n              serviceUuid: service.uuid\n            });\n          }\n        }\n        \n        // Read device information with retry\n        try {\n          console.log(\"Reading device information...\");\n          const deviceInfo = await this.readDeviceInformationWithRetry(device);\n          console.log(\"Device information:\", deviceInfo);\n          device.deviceInfo = deviceInfo;\n        } catch (error) {\n          console.error(\"Failed to read device information after retries:\", {\n            error: error instanceof Error ? error.message : 'Unknown error',\n            stack: error instanceof Error ? error.stack : undefined,\n            deviceId: device.id,\n            deviceName: device.name\n          });\n        }\n        \n        // Discover services and characteristics\n        const discoveredServices = await this.discoverServices(device);\n        device.services = discoveredServices;\n        \n        this.handleDeviceUpdate(device);\n        this.emit('deviceConnected', device);\n        \n        // Read all characteristics after connecting\n        await this.readAllCharacteristics(device);\n      }\n      return device;\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Failed to connect to device');\n      console.error('Error connecting to device:', {\n        error: err.message,\n        stack: err.stack,\n        deviceId: deviceId,\n        attemptedDevice: device ? {\n          id: device.id,\n          name: device.name\n        } : 'Device not found in local list'\n      });\n      this.emit('connectError', err);\n      throw err;\n    }\n  }\n\n  public async disconnectDevice(deviceId: string): Promise<void> {\n    console.log(\"Attempting to disconnect device:\", deviceId);\n    const device = this.devices.find(d => d.id === deviceId);\n    if (!device) {\n      console.log(\"Device not found for disconnection\");\n      const error = new Error('Device not found');\n      this.emit('disconnectError', error);\n      throw error;\n    }\n\n    try {\n      console.log(\"Disconnecting device:\", device.name || device.id);\n      if (device.gatt) {\n        // Set connected to false and clear the GATT server reference\n        device.isConnected = false;\n        device.gatt = undefined;\n      }\n      this.handleDeviceUpdate(device);\n      console.log(\"Device disconnected successfully:\", device.name || device.id);\n      this.emit('deviceDisconnected', device);\n    } catch (error) {\n      console.error(\"Error disconnecting device:\", error);\n      const err = error instanceof Error ? error : new Error('Failed to disconnect device');\n      this.emit('disconnectError', err);\n      throw err;\n    }\n  }\n\n  public removeDevice(deviceId: string): BluetoothDevice | null {\n    try {\n      console.log(\"Attempting to remove device:\", deviceId);\n      \n      const device = this.devices.find(d => d.id === deviceId);\n      if (!device) {\n        console.log(\"Device not found in list\");\n        return null;\n      }\n\n      // Clean up any active subscriptions for this device\n      for (const [key] of this.characteristicSubscriptions) {\n        if (key.startsWith(deviceId)) {\n          this.characteristicSubscriptions.delete(key);\n        }\n      }\n\n      // Clean up any active notifications for this device\n      for (const [key] of this.characteristicNotifications) {\n        if (key.startsWith(deviceId)) {\n          this.characteristicNotifications.delete(key);\n        }\n      }\n\n      // Remove the device\n      this.devices = this.devices.filter(d => d.id !== deviceId);\n      console.log(\"Device removed successfully\");\n      \n      this.saveDevices();\n      this.emit('devicesChanged', [...this.devices]);\n      return device;\n    } catch (error) {\n      console.error(\"Error removing device:\", error);\n      const err = error instanceof Error ? error : new Error('Failed to remove device');\n      this.emit('removeError', err);\n      throw err;\n    }\n  }\n\n  public getServiceName(uuid: string): string {\n    return this.gattLookup.getServiceName(uuid);\n  }\n\n  public async discoverServices(device: BluetoothDevice): Promise<Service[]> {\n    if (!device.gatt) {\n      const error = new Error('Device not connected');\n      this.emit('error', error);\n      throw error;\n    }\n\n    try {\n      const services = await device.gatt.getPrimaryServices();\n      return Promise.all(services.map(async (service) => {\n        try {\n          const characteristics = await service.getCharacteristics();\n          return {\n            uuid: service.uuid,\n            name: this.getServiceName(service.uuid),\n            characteristics: characteristics.map(char => ({\n              uuid: char.uuid,\n              name: this.getCharacteristicName(char.uuid),\n              properties: Object.keys(char.properties)\n            }))\n          };\n        } catch (error) {\n          const err = error instanceof Error ? error : new Error('Failed to get characteristics');\n          this.emit('error', err);\n          throw err;\n        }\n      }));\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Failed to discover services');\n      this.emit('error', err);\n      throw err;\n    }\n  }\n\n  public async readCharacteristic(\n    device: BluetoothDevice,\n    serviceUuid: string,\n    characteristicUuid: string\n  ): Promise<DataView> {\n    if (!device.gatt) {\n      const error = new Error('Device not connected');\n      this.emit('error', error);\n      throw error;\n    }\n\n    try {\n      const service = await device.gatt.getPrimaryService(serviceUuid);\n      const characteristic = await service.getCharacteristic(characteristicUuid);\n      return characteristic.readValue();\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Failed to read characteristic');\n      this.emit('error', err);\n      throw err;\n    }\n  }\n\n  public async refreshDevices(deviceId?: string): Promise<void> {\n    try {\n      console.log(\"Refreshing devices list\", deviceId ? `for device ${deviceId}` : \"\");\n      // Reload devices from storage\n      this.loadDevices();\n      \n      // Update connection status for devices\n      for (const device of this.devices) {\n        // If a specific deviceId is provided, only check that device\n        if (deviceId && device.id !== deviceId) {\n          continue;\n        }\n\n        try {\n          // If device has a GATT server, check if it's still connected\n          if (device.gatt) {\n            // The Web Bluetooth API doesn't provide a direct way to check connection status\n            // So we'll try to get a service to verify the connection\n            try {\n              await device.gatt.getPrimaryService('battery_service');\n              device.isConnected = true;\n              console.log(`Device ${device.id} is connected`);\n            } catch (error) {\n              // If we can't get a service, the device is disconnected\n              device.isConnected = false;\n              device.gatt = undefined;\n              console.log(`Device ${device.id} is disconnected`);\n            }\n          } else {\n            device.isConnected = false;\n          }\n          device.lastSeen = new Date();\n        } catch (error) {\n          device.isConnected = false;\n          device.gatt = undefined;\n          console.log(`Device ${device.id} is not connected`);\n        }\n      }\n      \n      this.saveDevices();\n      this.emit('devicesChanged', [...this.devices]);\n    } catch (error) {\n      console.error(\"Error refreshing devices:\", error);\n      const err = error instanceof Error ? error : new Error('Failed to refresh devices');\n      this.emit('error', err);\n      throw err;\n    }\n  }\n\n  public registerCustomCharacteristic(characteristic: CustomCharacteristic) {\n    // Check if characteristic already exists\n    const exists = this.customCharacteristics.some(c => c.uuid === characteristic.uuid);\n    if (!exists) {\n      this.customCharacteristics.push(characteristic);\n      console.log(`Registered custom characteristic: ${characteristic.name} (${characteristic.uuid})`);\n    }\n  }\n\n  public unregisterCustomCharacteristic(uuid: string) {\n    this.customCharacteristics = this.customCharacteristics.filter(c => c.uuid !== uuid);\n  }\n\n  public async readDeviceInformation(device: BluetoothDevice): Promise<DeviceInformation> {\n    if (!device.gatt) {\n      throw new Error('Device not connected');\n    }\n\n    try {\n      const deviceInfoService = await device.gatt.getPrimaryService('device_information');\n      const info: DeviceInformation = {};\n\n      // Base list of standard device information characteristics\n      const standardCharacteristics: Array<{\n        uuid: string;\n        key: string;\n        name: string;\n        valueFormatter?: (value: DataView) => string;\n      }> = [\n        { uuid: 'manufacturer_name_string', key: 'manufacturerName', name: 'Manufacturer Name' },\n        { uuid: 'model_number_string', key: 'modelNumber', name: 'Model Number' },\n        { uuid: 'serial_number_string', key: 'serialNumber', name: 'Serial Number' },\n        { uuid: 'hardware_revision_string', key: 'hardwareRevision', name: 'Hardware Revision' },\n        { uuid: 'firmware_revision_string', key: 'firmwareRevision', name: 'Firmware Revision' },\n        { uuid: 'software_revision_string', key: 'softwareRevision', name: 'Software Revision' },\n        { uuid: 'system_id', key: 'systemId', name: 'System ID' },\n        { uuid: 'ieee_11073-20601_regulatory_certification_data_list', key: 'ieee11073', name: 'IEEE 11073' },\n        { uuid: 'pnp_id', key: 'pnpId', name: 'PnP ID' }\n      ];\n\n      // Combine standard and custom characteristics\n      const allCharacteristics = [...standardCharacteristics, ...this.customCharacteristics];\n\n      // Try to read each characteristic\n      for (const { uuid, key, name, valueFormatter } of allCharacteristics) {\n        try {\n          const characteristic = await deviceInfoService.getCharacteristic(uuid);\n          const value = await characteristic.readValue();\n          \n          // Use custom formatter if provided, otherwise use default formatting\n          if (valueFormatter) {\n            info[key as keyof DeviceInformation] = valueFormatter(value);\n          } else if (uuid === 'system_id' || uuid === 'pnp_id') {\n            // Convert to hex string\n            const hexArray = Array.from(new Uint8Array(value.buffer))\n              .map(b => b.toString(16).padStart(2, '0'));\n            info[key as keyof DeviceInformation] = hexArray.join(':');\n          } else {\n            // Convert to string\n            info[key as keyof DeviceInformation] = new TextDecoder().decode(value);\n          }\n          \n          console.log(`Read ${name}:`, info[key as keyof DeviceInformation]);\n        } catch (error) {\n          console.log(`Characteristic ${name} (${uuid}) not available:`, error);\n          // Don't throw, just continue with next characteristic\n        }\n      }\n\n      // Log the complete device information\n      console.log('Complete Device Information:', info);\n      return info;\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Failed to read device information');\n      this.emit('error', err);\n      throw err;\n    }\n  }\n\n  public async readBatteryLevel(device: BluetoothDevice): Promise<number | null> {\n    if (!device.gatt) {\n      throw new Error('Device not connected');\n    }\n\n    try {\n      const batteryService = await device.gatt.getPrimaryService('battery_service');\n      const batteryLevelChar = await batteryService.getCharacteristic('battery_level');\n      const value = await batteryLevelChar.readValue();\n      return value.getUint8(0);\n    } catch (error) {\n      console.log('Battery level not available');\n      return null;\n    }\n  }\n\n  private async readCharacteristicString(characteristic: BluetoothRemoteGATTCharacteristic): Promise<string> {\n    const value = await characteristic.readValue();\n    return new TextDecoder().decode(value);\n  }\n\n  public getCharacteristicName(uuid: string): string {\n    return this.gattLookup.getCharacteristicName(uuid);\n  }\n\n  public async readAllCharacteristics(device: BluetoothDevice): Promise<void> {\n    if (!device.gatt) {\n      throw new Error('Device not connected');\n    }\n\n    try {\n      const services = await device.gatt.getPrimaryServices();\n      for (const service of services) {\n        try {\n          const characteristics = await service.getCharacteristics();\n          for (const characteristic of characteristics) {\n            try {\n              if (characteristic.properties.read) {\n                const value = await characteristic.readValue();\n                this.characteristicValues.set(characteristic.uuid, value);\n                this.emit('characteristicRead', {\n                  uuid: characteristic.uuid,\n                  name: this.getCharacteristicName(characteristic.uuid),\n                  properties: Object.keys(characteristic.properties),\n                  value,\n                  lastUpdated: new Date()\n                });\n              }\n            } catch (error) {\n              console.error(`Failed to read characteristic ${characteristic.uuid}:`, error);\n            }\n          }\n        } catch (error) {\n          console.error(`Failed to get characteristics for service ${service.uuid}:`, error);\n        }\n      }\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Failed to read characteristics');\n      this.emit('error', err);\n      throw err;\n    }\n  }\n\n  public getCharacteristicValue(uuid: string): DataView | undefined {\n    return this.characteristicValues.get(uuid);\n  }\n\n  public async startNotifications(\n    device: BluetoothDevice,\n    serviceUuid: string,\n    characteristicUuid: string\n  ): Promise<void> {\n    if (!device.gatt) {\n      throw new Error('Device not connected');\n    }\n\n    try {\n      const service = await device.gatt.getPrimaryService(serviceUuid);\n      const characteristic = await service.getCharacteristic(characteristicUuid);\n      \n      const key = `${device.id}-${serviceUuid}-${characteristicUuid}`;\n      const notificationHandler = (event: Event) => {\n        const target = event.target as BluetoothRemoteGATTCharacteristic;\n        const value = target.value;\n        if (value) {\n          this.characteristicValues.set(characteristicUuid, value);\n          this.emit('characteristicRead', {\n            uuid: characteristicUuid,\n            name: this.getCharacteristicName(characteristicUuid),\n            properties: Object.keys(characteristic.properties),\n            value,\n            lastUpdated: new Date()\n          });\n        }\n      };\n\n      await characteristic.startNotifications();\n      characteristic.addEventListener('characteristicvaluechanged', notificationHandler);\n      this.characteristicNotifications.set(key, notificationHandler);\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Failed to start notifications');\n      this.emit('error', err);\n      throw err;\n    }\n  }\n\n  public async stopNotifications(\n    device: BluetoothDevice,\n    serviceUuid: string,\n    characteristicUuid: string\n  ): Promise<void> {\n    if (!device.gatt) {\n      throw new Error('Device not connected');\n    }\n\n    try {\n      const service = await device.gatt.getPrimaryService(serviceUuid);\n      const characteristic = await service.getCharacteristic(characteristicUuid);\n      \n      const key = `${device.id}-${serviceUuid}-${characteristicUuid}`;\n      const notificationHandler = this.characteristicNotifications.get(key);\n      \n      if (notificationHandler) {\n        characteristic.removeEventListener('characteristicvaluechanged', notificationHandler);\n        this.characteristicNotifications.delete(key);\n        await characteristic.stopNotifications();\n      }\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Failed to stop notifications');\n      this.emit('error', err);\n      throw err;\n    }\n  }\n\n  public async subscribeToCharacteristic(\n    device: BluetoothDevice,\n    serviceUuid: string,\n    characteristicUuid: string,\n    callback: (value: string) => void\n  ): Promise<void> {\n    if (!device.gatt) {\n      throw new Error('Device not connected');\n    }\n\n    try {\n      const service = await device.gatt.getPrimaryService(serviceUuid);\n      const characteristic = await service.getCharacteristic(characteristicUuid);\n\n      // Check if notifications are supported\n      if (!characteristic.properties.notify) {\n        throw new Error('Characteristic does not support notifications');\n      }\n\n      const key = `${device.id}-${serviceUuid}-${characteristicUuid}`;\n      \n      // Add callback to subscriptions\n      if (!this.characteristicSubscriptions.has(key)) {\n        this.characteristicSubscriptions.set(key, new Set());\n      }\n      this.characteristicSubscriptions.get(key)?.add(callback);\n\n      // Set up notification handler if not already set up\n      if (!this.characteristicNotifications.has(key)) {\n        const notificationHandler = (event: Event) => {\n          const target = event.target as BluetoothRemoteGATTCharacteristic;\n          const value = target.value;\n          if (value) {\n            // Get custom formatter if available\n            const customChar = this.customCharacteristics.find(c => c.uuid === characteristicUuid);\n            const formattedValue = customChar?.valueFormatter \n              ? customChar.valueFormatter(value)\n              : new TextDecoder().decode(value);\n\n            // Call all subscribed callbacks\n            this.characteristicSubscriptions.get(key)?.forEach(cb => cb(formattedValue));\n          }\n        };\n\n        await characteristic.startNotifications();\n        characteristic.addEventListener('characteristicvaluechanged', notificationHandler);\n        this.characteristicNotifications.set(key, notificationHandler);\n      }\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Failed to subscribe to characteristic');\n      this.emit('error', err);\n      throw err;\n    }\n  }\n\n  public async unsubscribeFromCharacteristic(\n    device: BluetoothDevice,\n    serviceUuid: string,\n    characteristicUuid: string,\n    callback: (value: string) => void\n  ): Promise<void> {\n    const key = `${device.id}-${serviceUuid}-${characteristicUuid}`;\n    this.characteristicSubscriptions.get(key)?.delete(callback);\n\n    // If no more callbacks, stop notifications\n    if (this.characteristicSubscriptions.get(key)?.size === 0) {\n      const notificationHandler = this.characteristicNotifications.get(key);\n      if (notificationHandler && device.gatt) {\n        try {\n          const service = await device.gatt.getPrimaryService(serviceUuid);\n          const characteristic = await service.getCharacteristic(characteristicUuid);\n          characteristic.removeEventListener('characteristicvaluechanged', notificationHandler);\n          await characteristic.stopNotifications();\n        } catch (error) {\n          console.error('Error stopping notifications:', error);\n        }\n      }\n      this.characteristicNotifications.delete(key);\n      this.characteristicSubscriptions.delete(key);\n    }\n  }\n\n  async pairDevice(device: BluetoothDevice): Promise<void> {\n    try {\n      console.log('Pairing device:', device);\n      const pairedDevice = await device.gatt?.connect();\n      if (!pairedDevice) {\n        throw new Error('Failed to pair with device');\n      }\n\n      // Add the device to our list\n      const deviceInfo: Device = {\n        id: device.id,\n        name: device.name || 'Unknown Device',\n        isConnected: false,\n        isPaired: true,\n        lastSeen: new Date(),\n        services: [],\n        characteristics: []\n      };\n\n      this.devices.push(deviceInfo);\n      await this.saveDevices();\n      this.emit('devicesChanged', [...this.devices]);\n      this.emit('devicePaired', deviceInfo);\n    } catch (error) {\n      console.error('Error pairing device:', error);\n      this.emit('error', {\n        type: 'pairing',\n        message: error instanceof Error ? error.message : 'Failed to pair with device'\n      });\n      throw error;\n    }\n  }\n} ",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/bluetooth/gatt-services.ts",
      "content": "export interface GattService {\n  uuid: string;\n  name: string;\n}\n\nexport interface GattCharacteristic {\n  uuid: string;\n  name: string;\n}\n\nexport class GattLookup {\n  private static instance: GattLookup;\n  private serviceMap: Map<string, GattService>;\n  private characteristicMap: Map<string, GattCharacteristic>;\n\n  private constructor() {\n    // Create maps for quick lookup by first segment\n    this.serviceMap = new Map();\n    this.characteristicMap = new Map();\n\n    // Populate service map\n    GATT_SERVICES.map(service => {\n      const firstSegment = this.getFirstSegment(service.uuid);\n      this.serviceMap.set(firstSegment, service);\n    });\n\n    // Populate characteristic map\n    GATT_CHARACTERISTICS.map(char => {\n      const firstSegment = this.getFirstSegment(char.uuid);\n\n      this.characteristicMap.set(firstSegment, char);\n    });\n\n    console.log(\"serviceMap\", this.serviceMap);\n    console.log(\"characteristicMap\", this.characteristicMap);\n  }\n\n  public static getInstance(): GattLookup {\n    if (!GattLookup.instance) {\n      GattLookup.instance = new GattLookup();\n    }\n    return GattLookup.instance;\n  }\n \n  private getFirstSegment(uuid: string): string {\n    // Get the characters until the first '-'\n    // console.log(\"uuid\", uuid);\n    // if the uuid doesn't have a '-' then return the uuid\n    if (!uuid.includes('-')) {\n      return uuid.toUpperCase();\n    }\n    const firstSegment = uuid.substring(0, uuid.indexOf('-'));\n    return firstSegment.toUpperCase();\n  }\n\n  public getServiceByFirstSegment(uuid: string): GattService | undefined {\n    const firstSegment = this.getFirstSegment(uuid);\n    // console.log(\"firstSegment\", firstSegment);\n    return this.serviceMap.get(firstSegment);\n  }\n\n  public getCharacteristicByFirstSegment(uuid: string): GattCharacteristic | undefined {\n    const firstSegment = this.getFirstSegment(uuid);\n    // console.log(\"firstSegment\", firstSegment, this.characteristicMap);\n    return this.characteristicMap.get(firstSegment);\n  }\n\n  public getServiceName(uuid: string): string {\n    const service = this.getServiceByFirstSegment(uuid);\n    return service?.name || uuid;\n  }\n\n  public getCharacteristicName(uuid: string): string {\n    const characteristic = this.getCharacteristicByFirstSegment(uuid);\n    console.log(\"characteristic\", characteristic, uuid);\n    return characteristic?.name || uuid;\n  }\n}\n\nexport const GATT_SERVICES: GattService[] = [\n  { uuid: '00001800', name: 'Generic Access' },\n  { uuid: '00001801', name: 'Generic Attribute' },\n  { uuid: '00001802', name: 'Immediate Alert' },\n  { uuid: '00001803', name: 'Link Loss' },\n  { uuid: '00001804', name: 'Tx Power' },\n  { uuid: '00001805', name: 'Current Time' },\n  { uuid: '00001806', name: 'Reference Time Update' },\n  { uuid: '00001807', name: 'Next DST Change' },\n  { uuid: '00001808', name: 'Glucose' },\n  { uuid: '00001809', name: 'Health Thermometer' },\n  { uuid: '0000180A', name: 'Device Information' },\n  { uuid: '0000180D', name: 'Heart Rate' },\n  { uuid: '0000180E', name: 'Phone Alert Status' },\n  { uuid: '0000180F', name: 'Battery Service' },\n  { uuid: '00001810', name: 'Blood Pressure' },\n  { uuid: '00001811', name: 'Alert Notification' },\n  { uuid: '00001812', name: 'Human Interface Device' },\n  { uuid: '00001813', name: 'Scan Parameters' },\n  { uuid: '00001814', name: 'Running Speed and Cadence' },\n  { uuid: '00001815', name: 'Automation IO' },\n  { uuid: '00001816', name: 'Cycling Speed and Cadence' },\n  { uuid: '00001818', name: 'Cycling Power' },\n  { uuid: '00001819', name: 'Location and Navigation' },\n  { uuid: '0000181A', name: 'Environmental Sensing' },\n  { uuid: '0000181B', name: 'Body Composition' },\n  { uuid: '0000181C', name: 'User Data' },\n  { uuid: '0000181D', name: 'Weight Scale' },\n  { uuid: '0000181E', name: 'Bond Management' },\n  { uuid: '0000181F', name: 'Continuous Glucose Monitoring' },\n  { uuid: '00001820', name: 'Internet Protocol Support' },\n  { uuid: '00001821', name: 'Indoor Positioning' },\n  { uuid: '00001822', name: 'Pulse Oximeter' },\n  { uuid: '00001823', name: 'HTTP Proxy' },\n  { uuid: '00001824', name: 'Transport Discovery' },\n  { uuid: '00001825', name: 'Object Transfer' },\n  { uuid: '00001826', name: 'Fitness Machine' },\n  { uuid: '00001827', name: 'Mesh Provisioning' },\n  { uuid: '00001828', name: 'Mesh Proxy' },\n  { uuid: '00001829', name: 'Reconnection Configuration' }\n];\n\nexport const GATT_CHARACTERISTICS: GattCharacteristic[] = [\n  { uuid: '00002a00', name: 'Device Name' },\n  { uuid: '00002a01', name: 'Appearance' },\n  { uuid: '00002a02', name: 'Peripheral Privacy Flag' },\n  { uuid: '00002a03', name: 'Reconnection Address' },\n  { uuid: '00002a04', name: 'Peripheral Preferred Connection Parameters' },\n  { uuid: '00002a05', name: 'Service Changed' },\n  { uuid: '00002a06', name: 'Alert Level' },\n  { uuid: '00002a07', name: 'Tx Power Level' },\n  { uuid: '00002a08', name: 'Date Time' },\n  { uuid: '00002a09', name: 'Day of Week' },\n  { uuid: '00002a0a', name: 'Day Date Time' },\n  { uuid: '00002a0b', name: 'Exact Time 100' },\n  { uuid: '00002a0c', name: 'Exact Time 256' },\n  { uuid: '00002a0d', name: 'DST Offset' },\n  { uuid: '00002a0e', name: 'Time Zone' },\n  { uuid: '00002a0f', name: 'Local Time Information' },\n  { uuid: '00002a10', name: 'Secondary Time Zone' },\n  { uuid: '00002a11', name: 'Time with DST' },\n  { uuid: '00002a12', name: 'Time Accuracy' },\n  { uuid: '00002a13', name: 'Time Source' },\n  { uuid: '00002a14', name: 'Reference Time Information' },\n  { uuid: '00002a15', name: 'Time Broadcast' },\n  { uuid: '00002a16', name: 'Time Update Control Point' },\n  { uuid: '00002a17', name: 'Time Update State' },\n  { uuid: '00002a18', name: 'Glucose Measurement' },\n  { uuid: '00002a19', name: 'Battery Level' },\n  { uuid: '00002a1a', name: 'Battery Power State' },\n  { uuid: '00002a1b', name: 'Battery Level State' },\n  { uuid: '00002a1c', name: 'Temperature Measurement' },\n  { uuid: '00002a1d', name: 'Temperature Type' },\n  { uuid: '00002a1e', name: 'Intermediate Temperature' },\n  { uuid: '00002a1f', name: 'Temperature Celsius' },\n  { uuid: '00002a20', name: 'Temperature Fahrenheit' },\n  { uuid: '00002a21', name: 'Measurement Interval' },\n  { uuid: '00002a22', name: 'Boot Keyboard Input Report' },\n  { uuid: '00002a23', name: 'System ID' },\n  { uuid: '00002a24', name: 'Model Number String' },\n  { uuid: '00002a25', name: 'Serial Number String' },\n  { uuid: '00002a26', name: 'Firmware Revision String' },\n  { uuid: '00002a27', name: 'Hardware Revision String' },\n  { uuid: '00002a28', name: 'Software Revision String' },\n  { uuid: '00002a29', name: 'Manufacturer Name String' },\n  { uuid: '00002a2a', name: 'IEEE 11073-20601 Regulatory Certification Data List' },\n  { uuid: '00002a2b', name: 'Current Time' },\n  { uuid: '00002a2c', name: 'Magnetic Declination' },\n  { uuid: '00002a2f', name: 'Position 2D' },\n  { uuid: '00002a30', name: 'Position 3D' },\n  { uuid: '00002a31', name: 'Scan Refresh' },\n  { uuid: '00002a32', name: 'Boot Keyboard Output Report' },\n  { uuid: '00002a33', name: 'Boot Mouse Input Report' },\n  { uuid: '00002a34', name: 'Glucose Measurement Context' },\n  { uuid: '00002a35', name: 'Blood Pressure Measurement' },\n  { uuid: '00002a36', name: 'Intermediate Cuff Pressure' },\n  { uuid: '00002a37', name: 'Heart Rate Measurement' },\n  { uuid: '00002a38', name: 'Body Sensor Location' },\n  { uuid: '00002a39', name: 'Heart Rate Control Point' },\n  { uuid: '00002a3a', name: 'Removable' },\n  { uuid: '00002a3b', name: 'Service Required' },\n  { uuid: '00002a3c', name: 'Scientific Temperature Celsius' },\n  { uuid: '00002a3d', name: 'String' },\n  { uuid: '00002a3e', name: 'Network Availability' },\n  { uuid: '00002a3f', name: 'Alert Status' },\n  { uuid: '00002a40', name: 'Ringer Control point' },\n  { uuid: '00002a41', name: 'Ringer Setting' },\n  { uuid: '00002a42', name: 'Alert Category ID Bit Mask' },\n  { uuid: '00002a43', name: 'Alert Category ID' },\n  { uuid: '00002a44', name: 'Alert Notification Control Point' },\n  { uuid: '00002a45', name: 'Unread Alert Status' },\n  { uuid: '00002a46', name: 'New Alert' },\n  { uuid: '00002a47', name: 'Supported New Alert Category' },\n  { uuid: '00002a48', name: 'Supported Unread Alert Category' },\n  { uuid: '00002a49', name: 'Blood Pressure Feature' },\n  { uuid: '00002a4a', name: 'HID Information' },\n  { uuid: '00002a4b', name: 'Report Map' },\n  { uuid: '00002a4c', name: 'HID Control Point' },\n  { uuid: '00002a4d', name: 'Report' },\n  { uuid: '00002a4e', name: 'Protocol Mode' },\n  { uuid: '00002a4f', name: 'Scan Interval Window' },\n  { uuid: '00002a50', name: 'PnP ID' },\n  { uuid: '00002a51', name: 'Glucose Feature' },\n  { uuid: '00002a52', name: 'Record Access Control Point' },\n  { uuid: '00002a53', name: 'RSC Measurement' },\n  { uuid: '00002a54', name: 'RSC Feature' },\n  { uuid: '00002a55', name: 'SC Control Point' },\n  { uuid: '00002a56', name: 'Digital' },\n  { uuid: '00002a57', name: 'Digital Output' },\n  { uuid: '00002a58', name: 'Analog' },\n  { uuid: '00002a59', name: 'Analog Output' },\n  { uuid: '00002a5a', name: 'Aggregate' },\n  { uuid: '00002a5b', name: 'CSC Measurement' },\n  { uuid: '00002a5c', name: 'CSC Feature' },\n  { uuid: '00002a5d', name: 'Sensor Location' },\n  { uuid: '00002a5e', name: 'PLX Spot-Check Measurement' },\n  { uuid: '00002a5f', name: 'PLX Continuous Measurement Characteristic' },\n  { uuid: '00002a60', name: 'PLX Features' },\n  { uuid: '00002a62', name: 'Pulse Oximetry Control Point' },\n  { uuid: '00002a63', name: 'Cycling Power Measurement' },\n  { uuid: '00002a64', name: 'Cycling Power Vector' },\n  { uuid: '00002a65', name: 'Cycling Power Feature' },\n  { uuid: '00002a66', name: 'Cycling Power Control Point' },\n  { uuid: '00002a67', name: 'Location and Speed Characteristic' },\n  { uuid: '00002a68', name: 'Navigation' },\n  { uuid: '00002a69', name: 'Position Quality' },\n  { uuid: '00002a6a', name: 'LN Feature' },\n  { uuid: '00002a6b', name: 'LN Control Point' },\n  { uuid: '00002a6c', name: 'Elevation' },\n  { uuid: '00002a6d', name: 'Pressure' },\n  { uuid: '00002a6e', name: 'Temperature' },\n  { uuid: '00002a6f', name: 'Humidity' },\n  { uuid: '00002a70', name: 'True Wind Speed' },\n  { uuid: '00002a71', name: 'True Wind Direction' },\n  { uuid: '00002a72', name: 'Apparent Wind Speed' },\n  { uuid: '00002a73', name: 'Apparent Wind Direction' },\n  { uuid: '00002a74', name: 'Gust Factor' },\n  { uuid: '00002a75', name: 'Pollen Concentration' },\n  { uuid: '00002a76', name: 'UV Index' },\n  { uuid: '00002a77', name: 'Irradiance' },\n  { uuid: '00002a78', name: 'Rainfall' },\n  { uuid: '00002a79', name: 'Wind Chill' },\n  { uuid: '00002a7a', name: 'Heat Index' },\n  { uuid: '00002a7b', name: 'Dew Point' },\n  { uuid: '00002a7d', name: 'Descriptor Value Changed' },\n  { uuid: '00002a7e', name: 'Aerobic Heart Rate Lower Limit' },\n  { uuid: '00002a7f', name: 'Aerobic Threshold' },\n  { uuid: '00002a80', name: 'Age' },\n  { uuid: '00002a81', name: 'Anaerobic Heart Rate Lower Limit' },\n  { uuid: '00002a82', name: 'Anaerobic Heart Rate Upper Limit' },\n  { uuid: '00002a83', name: 'Anaerobic Threshold' },\n  { uuid: '00002a84', name: 'Aerobic Heart Rate Upper Limit' },\n  { uuid: '00002a85', name: 'Date of Birth' },\n  { uuid: '00002a86', name: 'Date of Threshold Assessment' },\n  { uuid: '00002a87', name: 'Email Address' },\n  { uuid: '00002a88', name: 'Fat Burn Heart Rate Lower Limit' },\n  { uuid: '00002a89', name: 'Fat Burn Heart Rate Upper Limit' },\n  { uuid: '00002a8a', name: 'First Name' },\n  { uuid: '00002a8b', name: 'Five Zone Heart Rate Limits' },\n  { uuid: '00002a8c', name: 'Gender' },\n  { uuid: '00002a8d', name: 'Heart Rate Max' },\n  { uuid: '00002a8e', name: 'Height' },\n  { uuid: '00002a8f', name: 'Hip Circumference' },\n  { uuid: '00002a90', name: 'Last Name' },\n  { uuid: '00002a91', name: 'Maximum Recommended Heart Rate' },\n  { uuid: '00002a92', name: 'Resting Heart Rate' },\n  { uuid: '00002a93', name: 'Sport Type for Aerobic and Anaerobic Thresholds' },\n  { uuid: '00002a94', name: 'Three Zone Heart Rate Limits' },\n  { uuid: '00002a95', name: 'Two Zone Heart Rate Limit' },\n  { uuid: '00002a96', name: 'VO2 Max' },\n  { uuid: '00002a97', name: 'Waist Circumference' },\n  { uuid: '00002a98', name: 'Weight' },\n  { uuid: '00002a99', name: 'Database Change Increment' },\n  { uuid: '00002a9a', name: 'User Index' },\n  { uuid: '00002a9b', name: 'Body Composition Feature' },\n  { uuid: '00002a9c', name: 'Body Composition Measurement' },\n  { uuid: '00002a9d', name: 'Weight Measurement' },\n  { uuid: '00002a9e', name: 'Weight Scale Feature' },\n  { uuid: '00002a9f', name: 'User Control Point' },\n  { uuid: '00002aa0', name: 'Magnetic Flux Density - 2D' },\n  { uuid: '00002aa1', name: 'Magnetic Flux Density - 3D' },\n  { uuid: '00002aa2', name: 'Language' },\n  { uuid: '00002aa3', name: 'Barometric Pressure Trend' },\n  { uuid: '00002aa4', name: 'Bond Management Control Point' },\n  { uuid: '00002aa5', name: 'Bond Management Features' },\n  { uuid: '00002aa6', name: 'Central Address Resolution' },\n  { uuid: '00002aa7', name: 'CGM Measurement' },\n  { uuid: '00002aa8', name: 'CGM Feature' },\n  { uuid: '00002aa9', name: 'CGM Status' },\n  { uuid: '00002aaa', name: 'CGM Session Start Time' },\n  { uuid: '00002aab', name: 'CGM Session Run Time' },\n  { uuid: '00002aac', name: 'CGM Specific Ops Control Point' },\n  { uuid: '00002aad', name: 'Indoor Positioning Configuration' },\n  { uuid: '00002aae', name: 'Latitude' },\n  { uuid: '00002aaf', name: 'Longitude' },\n  { uuid: '00002ab0', name: 'Local North Coordinate' },\n  { uuid: '00002ab1', name: 'Local East Coordinate' },\n  { uuid: '00002ab2', name: 'Floor Number' },\n  { uuid: '00002ab3', name: 'Altitude' },\n  { uuid: '00002ab4', name: 'Uncertainty' },\n  { uuid: '00002ab5', name: 'Location Name' },\n  { uuid: '00002ab6', name: 'URI' },\n  { uuid: '00002ab7', name: 'HTTP Headers' },\n  { uuid: '00002ab8', name: 'HTTP Status Code' },\n  { uuid: '00002ab9', name: 'HTTP Entity Body' },\n  { uuid: '00002aba', name: 'HTTP Control Point' },\n  { uuid: '00002abb', name: 'HTTPS Security' },\n  { uuid: '00002abc', name: 'TDS Control Point' },\n  { uuid: '00002abd', name: 'OTS Feature' },\n  { uuid: '00002abe', name: 'Object Name' },\n  { uuid: '00002abf', name: 'Object Type' },\n  { uuid: '00002ac0', name: 'Object Size' },\n  { uuid: '00002ac1', name: 'Object First-Created' },\n  { uuid: '00002ac2', name: 'Object Last-Modified' },\n  { uuid: '00002ac3', name: 'Object ID' },\n  { uuid: '00002ac4', name: 'Object Properties' },\n  { uuid: '00002ac5', name: 'Object Action Control Point' },\n  { uuid: '00002ac6', name: 'Object List Control Point' },\n  { uuid: '00002ac7', name: 'Object List Filter' },\n  { uuid: '00002ac8', name: 'Object Changed' },\n  { uuid: '00002ac9', name: 'Resolvable Private Address Only' },\n  { uuid: '00002acc', name: 'Fitness Machine Feature' },\n  { uuid: '00002acd', name: 'Treadmill Data' },\n  { uuid: '00002ace', name: 'Cross Trainer Data' },\n  { uuid: '00002acf', name: 'Step Climber Data' },\n  { uuid: '00002ad0', name: 'Stair Climber Data' },\n  { uuid: '00002ad1', name: 'Rower Data' },\n  { uuid: '00002ad2', name: 'Indoor Bike Data' },\n  { uuid: '00002ad3', name: 'Training Status' },\n  { uuid: '00002ad4', name: 'Supported Speed Range' },\n  { uuid: '00002ad5', name: 'Supported Inclination Range' },\n  { uuid: '00002ad6', name: 'Supported Resistance Level Range' },\n  { uuid: '00002ad7', name: 'Supported Heart Rate Range' },\n  { uuid: '00002ad8', name: 'Supported Power Range' },\n  { uuid: '00002ad9', name: 'Fitness Machine Control Point' },\n  { uuid: '00002ada', name: 'Fitness Machine Status' },\n  { uuid: '00002aed', name: 'Date UTC' },\n  { uuid: '00002b1d', name: 'RC Feature' },\n  { uuid: '00002b1e', name: 'RC Settings' },\n  { uuid: '00002b1f', name: 'Reconnection Configuration Control Point' }\n]; ",
      "type": "registry:lib"
    }
  ]
}